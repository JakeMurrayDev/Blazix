@using Blazix.Services
@using Microsoft.JSInterop
@using Microsoft.Extensions.Logging

@implements IAsyncDisposable

@inject IJSRuntime JSRuntime
@inject IReadingDirectionService ReadingDirectionService
@inject ILogger<RovingFocusGroupRoot> Logger

<CascadingValue Value="@context"
                IsFixed="true">
    @ChildContent
</CascadingValue>

@code {
    private Lazy<Task<IJSObjectReference>>? moduleTask;
    private DotNetObjectReference<RovingFocusGroupRoot>? dotNetReference;
    private ElementReference? groupElement;
    private List<RovingFocusGroupItem> items = new();
    private bool isTabbingBackOut;
    private int focusableItemsCount;
    private IRovingFocusGroupContext? context;

    /// <summary>
    /// Gets or sets the orientation of the focusable items.
    /// </summary>
    [Parameter]
    public Orientation Orientation { get; set; }

    /// <summary>
    /// Gets or sets the reading direction. If set to <see cref="ReadingDirection.Undefined"/>, the value will be obtained from the <see cref="IReadingDirectionService"/>.
    /// </summary>
    [Parameter]
    public ReadingDirection ReadingDirection { get; set; }

    /// <summary>
    /// Determines whether focus should loop from the last to the first item and vice versa.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; }

    /// <summary>
    /// Gets or sets the identifier of the currently focused item. If not provided, the first focusable item will be focused by default.
    /// </summary>
    [Parameter]
    public string? CurrentTabStopId { get; set; }

    /// <summary>
    /// Gets or sets the default identifier of the currently focused item when <see cref="CurrentTabStopId"/> is not provided.
    /// </summary>
    [Parameter]
    public string? DefaultCurrentTabStopId { get; set; }

    /// <summary>
    /// Gets or sets a callback that is invoked when the <see cref="CurrentTabStopId"/> changes.
    /// </summary>
    [Parameter]
    public EventCallback<string?> CurrentTabStopIdChanged { get; set; }

    /// <summary>
    /// Gets or sets a callback that is invoked when the group receives focus.
    /// </summary>
    [Parameter]
    public EventCallback OnEntryFocus { get; set; }

    /// <summary>
    /// Determines whether to prevent scrolling when an item receives focus via the <see cref="OnEntryFocus"/> event.
    /// </summary>
    [Parameter]
    public bool PreventScrollOnEntryFocus { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets the tab index for the group element.
    /// </summary>
    public int TabIndex => isTabbingBackOut || focusableItemsCount == 0 ? -1 : 0;

    /// <summary>
    /// Gets the data-orientation attribute value based on the specified orientation.
    /// </summary>
    public string? DataOrientation => Orientation.ToDataAttributeString();

    /// <summary>
    /// Gets the inline style to remove the default focus outline.
    /// </summary>
    public string Style => "outline: none;";

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        moduleTask = new(() => JSRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./_content/Blazix/blazix-roving-focus-group.js").AsTask());

        var effectiveDir = ReadingDirection == ReadingDirection.Undefined
            ? ReadingDirectionService.GetReadingDirection()
            : ReadingDirection;

        context = new RovingFocusGroupContext(
            Orientation,
            effectiveDir,
            Loop,
            CurrentTabStopId ?? DefaultCurrentTabStopId,
            HandleItemFocus,
            HandleItemShiftTab,
            RegisterItem,
            UnregisterItem,
            () => items.Where(x => x.Focusable).ToArray());
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        dotNetReference?.Dispose();
        if (moduleTask?.IsValueCreated == true)
        {
            try
            {
                var module = await moduleTask.Value;
                if (groupElement.HasValue)
                {
                    await module.InvokeVoidAsync("disposeRovingFocusGroup",
                        groupElement.Value);
                }
                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
                // Swallow
            }
        }
    }


    /// <summary>
    /// Sets the associated <see cref="ElementReference"/>.
    /// </summary>
    /// <param name="element"></param>
    public void SetElement(ElementReference? element)
    {
        groupElement = element;
    }

    /// <summary>
    /// Method to initialize the roving focus functionality for this group.
    /// </summary>
    /// <returns></returns>
    public async Task InitializeAsync()
    {
        if (groupElement.HasValue)
        {
            try
            {
                var module = await moduleTask!.Value;
                dotNetReference = DotNetObjectReference.Create(this);
                await module.InvokeVoidAsync("initializeRovingFocusGroup",
                    groupElement.Value,
                    dotNetReference);
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
                // Swallow
            }
        }
    }

    [JSInvokable]
    public async Task HandleEntryFocusEvent()
    {
        var focusableItems = items.Where(x => x.Focusable).ToArray();
        var activeItem = focusableItems.FirstOrDefault(x => x.Active);
        var currentItem = focusableItems.FirstOrDefault(x =>
            x.TabStopId == (CurrentTabStopId ?? DefaultCurrentTabStopId));

        var candidateItems = new[] { activeItem, currentItem }
            .Concat(focusableItems)
            .Where(x => x != null)
            .Distinct()
            .ToArray();

        var candidateNodes = candidateItems
            .Where(x => x!.Element.HasValue)
            .Select(x => x!.Element!.Value)
            .ToArray();

        if (candidateNodes.Length > 0)
        {
            try
            {
                var module = await moduleTask!.Value;
                await module.InvokeVoidAsync("focusFirst",
                    candidateNodes,
                    PreventScrollOnEntryFocus);
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException)
            {
                // Swallow
            }
        }

        await OnEntryFocus.InvokeAsync();
    }

    [JSInvokable]
    public void HandleBlur()
    {
        isTabbingBackOut = false;
        StateHasChanged();
    }

    private void HandleItemFocus(string tabStopId)
    {
        if (CurrentTabStopId != tabStopId)
        {
            CurrentTabStopIdChanged.InvokeAsync(tabStopId);
        }
    }

    private void HandleItemShiftTab()
    {
        isTabbingBackOut = true;
        StateHasChanged();
    }

    private void RegisterItem(RovingFocusGroupItem item)
    {
        if (!items.Contains(item))
        {
            items.Add(item);
            if (item.Focusable)
            {
                focusableItemsCount++;
                StateHasChanged();
            }
        }
    }

    private void UnregisterItem(RovingFocusGroupItem item)
    {
        if (items.Remove(item))
        {
            if (item.Focusable)
            {
                focusableItemsCount--;
                StateHasChanged();
            }
        }
    }
}