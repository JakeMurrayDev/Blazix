@using System.Diagnostics.CodeAnalysis
@using System.Linq.Expressions
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop

@implements IAsyncDisposable

@inject IJSRuntime JSRuntime

<CascadingValue Value="context">
    <button type="button"
            role="switch"
            aria-checked="@CurrentValue.ToString().ToLowerInvariant()"
            aria-required="@(Required ? "true" : null)"
            data-state="@CurrentValue.GetDataState()"
            data-disabled="@(Disabled ? string.Empty : null)"
            disabled="@Disabled"
            value="@ValueAttribute"
            @attributes="AdditionalAttributes"
            id="@Id"
            @onclick="HandleClick"
            @onclick:stopPropagation="clickStopPropagation"
            @ref="Element">
        @ChildContent
    </button>

    @if (IsFormControl)
    {
        <InputCheckbox @ref="inputCheckbox"
                       aria-hidden="true"
                       name="@Name"
                       Value="@CurrentValue"
                       ValueChanged="@HandleCheckboxValueChanged"
                       ValueExpression="@CheckedExpression"
                       DisplayName="@DisplayName"
                       disabled="@Disabled"
                       required="@Required"
                       tabIndex="-1"
                       style="transform: translateX(-100%); position: absolute; pointer-events: none; opacity: 0; margin: 0;" />
    }
</CascadingValue>

@code {
    private readonly string defaultId = $"blx-{Guid.NewGuid():N}";

    private Lazy<Task<IJSObjectReference>> moduleTask = null!;
    private SwitchContext context = new(false, false);
    private bool internalCheckedState;
    private InputCheckbox? inputCheckbox;
    private bool clickStopPropagation;
    private bool isDisposed;

    private string Id => GetIdOrDefault(AdditionalAttributes, defaultId);

    private bool IsFormControl => EditContext != null;

    private bool IsControlled => CheckedChanged.HasDelegate;

    private bool CurrentValue => IsControlled ? Checked : internalCheckedState;

    [CascadingParameter]
    private EditContext? EditContext { get; set; }

    /// <summary>
    /// The checked state of the switch when it is initially rendered. Use when you do not need to control its checked state.
    /// </summary>
    [Parameter]
    public bool? DefaultChecked { get; set; }

    /// <summary>
    /// The controlled checked state of the switch.
    /// </summary>
    [Parameter]
    public bool Checked { get; set; }

    /// <summary>
    /// Event handler called when the checked state of the switch changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> CheckedChanged { get; set; }

    /// <summary>
    /// Gets or sets an expression that identifies the bound <see cref="Checked"/>.
    /// </summary>
    [Parameter]
    public Expression<Func<bool>>? CheckedExpression { get; set; }

    /// <summary>
    /// Gets or sets the display name of the switch.
    /// <para>
    /// This value is used when generating error messages when the input value fails to parse correctly.
    /// </para>
    /// </summary>
    [Parameter]
    public string? DisplayName { get; set; }

    /// <summary>
    /// When <see langword="true" />, prevents the user from interacting with the switch.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// When true, indicates that the user must check the switch before the owning form can be submitted.
    /// </summary>
    [Parameter]
    public bool Required { get; set; }

    /// <summary>
    /// The name of the switch. Submitted with its owning form as part of a name/value pair.
    /// </summary>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets the value given as data when submitted with a name.
    /// <para>
    /// Default value is "on".
    /// </para>
    /// </summary>
    [Parameter]
    public string ValueAttribute { get; set; } = "on";

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// <para>
    /// May be <see langword="null"/> if accessed before the component is rendered.
    /// </para>
    /// </summary>
    [DisallowNull]
    public ElementReference? Element { get; protected set; }

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        moduleTask = new(() => JSRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./_content/Blazix/blazix-checkbox.js").AsTask());

        if (!IsControlled)
        {
            internalCheckedState = DefaultChecked ?? false;
        }

        UpdateContext();
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        if (!IsControlled && internalCheckedState != (DefaultChecked ?? false))
        {
            internalCheckedState = DefaultChecked ?? false;
        }

        UpdateContext();
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && IsFormControl && inputCheckbox?.Element != null)
        {
            await SyncInputSize();
        }
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (isDisposed) return;
        isDisposed = true;

        if (moduleTask.IsValueCreated)
        {
            try
            {
                var module = await moduleTask.Value;
                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException) { }
        }
    }

    private void UpdateContext()
    {
        context = new SwitchContext(CurrentValue, Disabled);
    }

    private async Task SyncInputSize()
    {
        if (inputCheckbox?.Element == null || Element == null) return;

        try
        {
            var module = await moduleTask.Value;
            await module.InvokeVoidAsync("syncInputSize", Element, inputCheckbox.Element);
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException) { }
    }

    private async Task HandleClick(MouseEventArgs e)
    {
        if (Disabled) return;

        bool nextState = !CurrentValue;
        clickStopPropagation = false;

        if (IsControlled)
        {
            await CheckedChanged.InvokeAsync(nextState);
        }
        else
        {
            internalCheckedState = nextState;
            UpdateContext();
        }

        if (IsFormControl && inputCheckbox?.Element != null)
        {
            clickStopPropagation = true;

            try
            {
                var module = await moduleTask.Value;
                await module.InvokeVoidAsync("triggerInputEvents", inputCheckbox.Element, nextState, true);
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException) { }
        }
    }

    private Task HandleCheckboxValueChanged(bool newValue)
    {
        if (!IsControlled && internalCheckedState != newValue)
        {
            internalCheckedState = newValue;
            UpdateContext();
        }

        return Task.CompletedTask;
    }
}