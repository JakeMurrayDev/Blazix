@using Microsoft.JSInterop
@using Microsoft.Extensions.Logging

@implements IAsyncDisposable

@inject IJSRuntime JSRuntime
@inject ILogger<FocusScopeRoot> Logger

<CascadingValue Value="context"
                IsFixed="true">
    @ChildContent
</CascadingValue>

@code {
    private Lazy<Task<IJSObjectReference>>? moduleTask;
    private ElementReference? scopeElement;
    private IJSObjectReference? previouslyFocusedElement;
    private IFocusScopeContext? context;
    private bool isInitialized;

    /// <summary>
    /// When <see langword="true"/>, tabbing from last item will focus first tabbable
    /// and shift+tab from first item will focus last tabbable.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; }

    /// <summary>
    /// When <see langword="true"/>, focus cannot escape the focus scope via keyboard,
    /// pointer, or a programmatic focus.
    /// </summary>
    [Parameter]
    public bool Trapped { get; set; }

    /// <summary>
    /// Event callback invoked when auto-focusing on mount.
    /// Set <see cref="PreventableEventArgs.Prevented"/> to <see langword="true"/> to prevent default behavior.
    /// </summary>
    [Parameter]
    public EventCallback<PreventableEventArgs> OnMountAutoFocus { get; set; }

    /// <summary>
    /// Event callback invoked when auto-focusing on unmount.
    /// Set <see cref="PreventableEventArgs.Prevented"/> to <see langword="true"/> to prevent default behavior.
    /// </summary>
    [Parameter]
    public EventCallback<PreventableEventArgs> OnUnmountAutoFocus { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets the tab index for the focus scope container.
    /// </summary>
    public int TabIndex => -1;

    /// <summary>
    /// Gets the inline style for the focus scope container.
    /// </summary>
    public string Style => "outline: none;";

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        moduleTask = new(() => JSRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./_content/Blazix/blazix-focus-scope.js").AsTask());

        context = new FocusScopeContext(Loop, Trapped);
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        await CleanupAsync();

        if (moduleTask?.IsValueCreated == true)
        {
            try
            {
                var module = await moduleTask.Value;
                await module.DisposeAsync();
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException) { }
        }
    }

    /// <summary>
    /// Sets the element reference for the focus scope container.
    /// </summary>
    public void SetElement(ElementReference? element)
    {
        scopeElement = element;
    }

    /// <summary>
    /// Initializes the focus scope with JavaScript interop.
    /// </summary>
    public async Task InitializeAsync()
    {
        if (!scopeElement.HasValue || isInitialized) return;

        try
        {
            var module = await moduleTask!.Value;

            if (OnMountAutoFocus.HasDelegate)
            {
                var args = new PreventableEventArgs();
                await OnMountAutoFocus.InvokeAsync(args);
                if (args.Prevented)
                {
                    await module.InvokeVoidAsync("preventMountAutoFocus", scopeElement.Value);
                }
            }

            previouslyFocusedElement = await module.InvokeAsync<IJSObjectReference>(
                "initializeFocusScope",
                scopeElement.Value,
                Loop,
                Trapped,
                null);

            isInitialized = true;
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException) { }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize focus scope.");
        }
    }

    /// <summary>
    /// Cleans up the focus scope, restoring focus to the previously focused element.
    /// </summary>
    public async Task CleanupAsync()
    {
        if (!isInitialized || !scopeElement.HasValue) return;

        try
        {
            var module = await moduleTask!.Value;

            if (OnUnmountAutoFocus.HasDelegate)
            {
                var args = new PreventableEventArgs();
                await OnUnmountAutoFocus.InvokeAsync(args);
                if (args.Prevented)
                {
                    await module.InvokeVoidAsync("preventUnmountAutoFocus", scopeElement.Value);
                }
            }

            await module.InvokeVoidAsync("disposeFocusScope", scopeElement.Value, previouslyFocusedElement);
            previouslyFocusedElement = null;
            isInitialized = false;
        }
        catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException) { }
    }
}