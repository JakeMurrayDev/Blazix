@using Blazix.RovingFocusGroup
@using Blazix.Toggle

@typeparam TValue

<RovingFocusGroupItem @ref="rovingFocusGroupItem"
                      TabStopId="Id"
                      Focusable="!IsActuallyDisabled"
                      Active="IsPressed">
    @ToggleRootContent()
</RovingFocusGroupItem>

@code {
    private readonly string defaultId = $"blx-togglegroupitem-{Guid.NewGuid():N}";

    private RovingFocusGroupItem? rovingFocusGroupItem;
    private ToggleRoot? toggle;

    private string Id => GetIdOrDefault(AdditionalAttributes, defaultId);

    private bool IsPressed
    {
        get
        {
            if (Context != null && Value != null)
            {
                return Context.Multiple ? Context.SelectedValues?.Contains(Value) ?? false : EqualityComparer<TValue>.Default.Equals(Context.SelectedValue, Value);
            }

            return false;
        }
    }

    private bool IsActuallyDisabled => (Context?.GroupDisabled ?? false) || Disabled;

    [CascadingParameter]
    private ToggleGroupContext<TValue>? Context { get; set; }

    /// <summary>
    /// Gets or sets a unique value for the item.
    /// </summary>
    [Parameter, EditorRequired]
    public TValue? Value { get; set; }

    /// <summary>
    /// When <see langword="true"/>, prevents the user from interacting with the item.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Defines the child components of this instance.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets a collection of additional attributes that will be applied to the created element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Gets or sets the associated <see cref="ElementReference"/>.
    /// <para>
    /// May be <see langword="null"/> if accessed before the component is rendered.
    /// </para>
    /// </summary>
    public ElementReference? Element => toggle?.Element;

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        if (Context is null)
        {
            throw new InvalidOperationException($"'{GetType().Name}' must have an ancestor '{nameof(ToggleGroupRoot)}' that provides a '{nameof(ToggleGroupContext<TValue>)}'.");
        }
        if (Value is null || Value is string value && string.IsNullOrEmpty(value))
        {
            throw new ArgumentException($"Parameter '{nameof(Value)}' cannot be null or empty.", nameof(Value));
        }
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Context?.RovingFocusEnabled == true)
        {
            rovingFocusGroupItem?.SetElement(Element);
            await (rovingFocusGroupItem?.InitializeAsync() ?? Task.CompletedTask);
        }
    }

    private Task HandlePressedInternalAsync(bool pressed)
    {
        if (Value == null || Context == null || IsActuallyDisabled) return Task.CompletedTask;
        return Context.OnItemToggled(Value, pressed);
    }

    private Task HandleKeyDownAsync(KeyboardEventArgs e)
    {
        if (Context == null || !Context.RovingFocusEnabled || IsActuallyDisabled)
            return Task.CompletedTask;
        return rovingFocusGroupItem?.OnKeyDown(e) ?? Task.CompletedTask;
    }

    private void HandleFocus() => rovingFocusGroupItem?.Focus();

    private void HandleMouseDown() => rovingFocusGroupItem?.OnMouseDown();

    private RenderFragment ToggleRootContent() => builder =>
    {
        builder.OpenComponent<ToggleRoot>(0);
        builder.AddComponentParameter(1, nameof(ToggleRoot.Pressed), IsPressed);
        builder.AddComponentParameter(2, nameof(ToggleRoot.PressedChanged),
            EventCallback.Factory.Create<bool>(this, HandlePressedInternalAsync));
        builder.AddComponentParameter(3, nameof(ToggleRoot.Disabled), IsActuallyDisabled);
        builder.AddComponentParameter(4, nameof(ToggleRoot.ChildContent), ChildContent);
        builder.AddMultipleAttributes(5, AdditionalAttributes);
        builder.AddAttribute(6, "id", Id);

        if (Context?.RovingFocusEnabled == true)
        {
            builder.AddAttribute(7, "tabindex", rovingFocusGroupItem?.TabIndex);
            builder.AddAttribute(8, "data-orientation", rovingFocusGroupItem?.DataOrientation);
            builder.AddAttribute(9, "onkeydown",
                EventCallback.Factory.Create<KeyboardEventArgs>(this, HandleKeyDownAsync));
            builder.AddEventPreventDefaultAttribute(10, "onkeydown",
                rovingFocusGroupItem?.KeyDownPrevented ?? false);
            builder.AddAttribute(11, "onfocus",
                EventCallback.Factory.Create(this, HandleFocus));
            builder.AddAttribute(12, "onmousedown",
                EventCallback.Factory.Create(this, HandleMouseDown));
        }

        builder.AddComponentReferenceCapture(13, r => toggle = (ToggleRoot)r);
        builder.CloseComponent();
    };
}